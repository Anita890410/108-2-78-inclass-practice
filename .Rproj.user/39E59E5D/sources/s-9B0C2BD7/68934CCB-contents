---
title: '2020-06-17'
author: "anita"
date: "2020/6/12"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#5.3.4 switch
另一種條件式執行常用在condition種類煩雜或要全部以「是/否」問句來切出所有互斥condition情境不容易設計時。
*condition改成用文字描述，即conditionExpression。
*不同conditionExpression與對應body內容改成使用一對對的:
  *"conditionExpression文字"={body 內容} 的name=value pair
  *{body 內容}可省略{}，若內容只有一個值。
```{r}
switch(實現的conditionExpression,
       "conditionExpression1"={body 1},
       "conditionExpression2"={body 2},
       "conditionExpression3"={body 3},
       {其餘情境 body})
```
Mathematical function
f(n)={
n/2 if n is even
−(n+1)/2 if n is odd
```{r}
n<- 541.33
switch(
  as.character(n %% 2),
  "0"={fvalue <- n/2},
  "1"={fvalue <- -(n+1)/2},
  warning("n要整數喔")
)
```
也可以
```{r}
n <- 22
switch(
  as.character(n %% 2),
  "0"={n/2},
  "1"={-(n+1)/2},
  warning("n要整數喔")
) -> fvalue
```
任何{...}內「最後一個被執行的指令」若會印在螢幕的都可以當做回傳值存下來。
```{r}
n <- 22
switch(
  as.character(n %% 2),
  "0"=n/2,
  "1"=-(n+1)/2,
  warning("n要整數喔")
) -> fvalue
```
中文星期轉英文
```{r}
myWeekdays <- "星期一"
switch(myWeekdays,
        "星期一"="Monday",
        "星期二"="Tuesday",
        "星期三"="Wednesday",
        "星期四"="Thursday",
        "星期五"="Friday",
        "星期六"="Saturday",
        "星期日"="Sunday",
         warning("我們談的是地球的星期嗎？")
)
```
cut：連續轉類別
可適當使用cut()函數將與「連續型」數值變數有關的condition轉成需要的字串表示，
```{r}
cut(x, c(a,b,c))
```
會將x分成(a,b], (b,c], 及NA 三大類。
```{r}
a <- c(1,2,3)
cut(a, c(1,2,3))
```
其中最小值可以是負無窮-Inf, 最大值可以是正無窮Inf。

數字成績轉英文字母成績 成績等級：
>=90: A 同時螢幕出現“好棒棒”
80-89：B 同時螢幕出現“好棒”
70-79：C 同時螢幕出現“棒”
70以下：F 同時螢幕出現"-_-"

```{r}
grade <- sample(1:100, 10, replace=T)

# # 以下有誤： 因cut遇到整數會自動把cutpoints四捨五入
# grade %>%
#   cut(c(0,69.99,79.99,89.99,100)) -> grade

grade %>%
  cut(c(-1,69,79,89,100)) -> grade

levels(grade)

switch(
  as.character(grade[[1]]),
  "(-1,69]"={
    "-_-"
    "F"},
  "(69,79]"={
    "棒"
    "C"
    },
  "(79,89]"={
    "好棒"
    "B"
    },
  "(89,100]"={
    "好棒棒"
    "A"
    }
) -> letterGrade
```
寫一個compute_letterGrade(myGrade)函數, 可以依myGrade不同而回傳letterGrade且出現要求文字。

#5.3.5 logical condition
由於if, if…else, if…if else…else, 都是用來決定要不要執行某個body，所以(condition) 必需要是「一個」T/F logical value。

比對答案
```{r}
myAnswer <- c(2,3,6)
correctAnswer <- c(2,3,5)

if(myAnswer == correctAnswer){ # 只取用第一個T/F
  print("你答對了")
}
```
all,any
```{r}
myAnswer <- c(2,3,6)
correctAnswer <- c(2,3,5)

if(all(myAnswer == correctAnswer)){ # 要全TRUE
  print("你答對了")
}
```

```{r}
if(any(myAnswer == correctAnswer)){ # 只要有一個TRUE
  print("裡頭有數字是對的")
}
```
寫一個grading(myAnswer, correctAnswer)函數可以用來比對兩者是否class及所有元素都相同，是才回傳10分，不是回傳0分。

&& ||
有時「資訊到這裡就夠判斷情境」會產生，這時可以用&&或｜｜

對答案：
class, 內容都要對
```{r}
myAnswer <- c(1,2,3)
correctAnswer <- factor(c(1,2,3))

if(is.factor(myAnswer) && all(myAnswer==correctAnswer)){
  print("答對了")
  10
} else {
  print("答錯了")
  0
}-> myGrade
myGrade
```

```{r}
if(is.factor(myAnswer) & all(myAnswer==correctAnswer)){
  print("答對了")
  10
} else {
  print("答錯了")
  0
}-> myGrade
myGrade
```
*會計算所有relations，&&只計算到第一個出現FALSE的relation.
  *&&用在「有一個錯就算錯」的情境。
*|會計算所有relations，||只計算到第一個出現TRUE的relation.
  *||用在「有一個對就算對」的情境。
在進行condition execution時，使用&&, ||會比&, |更有運算效率。

condition最好少使用&或|因為兩邊relations若為logical向量長度>1，結果也會是個logical向量長度>1。

只要符合以下資格均可申請補助：
年齡>=65
家庭子孩數>3
```{r}
myAge <- 40
myChildrenNumber <- 5

if(myAge >=65 | myChildrenNumber >3){
  "符合申請資格"
} else {
  warning("不符合申請資格")
}

if(myAge >=65 ||  myChildrenNumber >3){
  "符合申請資格"
} else {
  warning("不符合申請資格")
}
```
那改成
```{r}
myAge <- 67
myChildrenNumber <- 5
```
